<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
输入url发生的事件


1.dns解析
2.建立连接
三次握手
3.发送数据
http
4.断开连接
四次挥手


重点是html渲染


1.解析html之后获取到dom树，遇到js则会执行js因为js可能有操作dom的方法
2.解析css生成cssom树，解析css的时候js执行会暂停，直到css规则书就绪；
3.合并cssom树和dom树形成渲染树
4.布局
5.分层
6.绘制



那些会导致重绘和重排的区别


lcp会获取最后一个最大的内容为结果

建议在2.5s之内



fcp 首次渲染内容

任何内容的一部分出现在页面的时间，也就是白屏时间

建议1.8s以内




fid  可交互时长

首次和网页互动到浏览器可以处理程序到相应的时间段

建议100ms以内

cls

整个生命周期发生的最大意外布局偏移分数


建议小于0.1s

性能优化方向

网络层面：
1.构建

webpack
减少打包体积：分割代码、按需加载、transnaking、动态垫片



拆包：split chunk分割各个模块的代码减少重复代码的出现

transnaking：可以移除重复代码和未使用代码，只对es模块生效，它针对的是静态分析，只有import+export才能提供静态打包功能
webpack将开发环境改为生产环境就可以生效；
按需加载： 我们可以把页面按照路由/功能单独打包成一个文件，使用时再加载。好处加快首屏渲染时间，

作用域提升：

原因：构建后的代码存在大量的函数闭包，创建函数的时候会创建很多作用域导致体积增大
解决：构建后的代码会按照引入的顺序放到一个作用域里边较少函数声明和内存

资源压缩：压缩js，html，css，图像可以减少打包体积  minify


减少打包时间：缩减打包范围、缓存、提前构建、并行构建
2.静态资源


图片压缩：实现自定义的插件在构建阶段接入一些图片压缩服务通过img-loader
也可以在发布之前做这事情



3.分发资源

内容分发网络


cdn静态资源可以走cdn


核心特点：缓存和回源

cnd缓存命中率
4.缓存优化
浏览器缓存

1.2为开发层面
3.4生产层面



渲染层面：
1.css优化
2.dom优化
缓存dom计算属性
避免过多的dom操作
3.js阻塞优化

有依赖使用defer
依赖不强使用async
4.重绘重排优化

减少不必要的dom操作

5.异步更新优化
    修改dom的时候改成微任务


优化策略：


首屏优化：有很多组件可以只渲染视窗内的组件  包括数据请求


文件已经到极限，就需要让js执行的更加的快速



1.组件预加载
2.公共js缓存：使用本地缓存

数据请求:

1.缓存数据
2.减少请求

使用bff合并请求处理


SSR
提前渲染出HTML，客户端访问的就是最终的页面内容
SSR还是需要网络请求，如果页面很复杂，HTML内容很大，还是存在白屏时长
CSR
客户端提前渲染出HTMI，理论上任何一个可以运行js引擎的地方，都可以做SSR


预渲染：当前页面可以渲染下一个可以访问的页面，需要客户端配合








</body>
</html>